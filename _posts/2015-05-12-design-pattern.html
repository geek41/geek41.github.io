---
layout: view_toc
comments: true
title: Design patten
categories: [java]
tags: [java]
date: 2014-6-10
keywords: java
description: java
---


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 设计原则</a>
<ul>
<li><a href="#sec-1-1">1.1. DRY</a></li>
<li><a href="#sec-1-2">1.2. 封装变化</a></li>
<li><a href="#sec-1-3">1.3. 针对接口编程,而不是针对实现编程</a></li>
<li><a href="#sec-1-4">1.4. 合成复用原则</a></li>
<li><a href="#sec-1-5">1.5. 里氏替换原则</a></li>
<li><a href="#sec-1-6">1.6. 单一职责原则</a></li>
<li><a href="#sec-1-7">1.7. 接口隔离原则</a></li>
<li><a href="#sec-1-8">1.8. 开闭原则</a></li>
<li><a href="#sec-1-9">1.9. 依赖倒转原则</a></li>
<li><a href="#sec-1-10">1.10. 迪米特法则</a></li>
<li><a href="#sec-1-11">1.11. 好莱坞原则</a></li>
</ul>
</li>
<li><a href="#sec-2">2. 23种设计模式</a>
<ul>
<li><a href="#sec-2-1">2.1. 创建型模式</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. 简单工厂(Simple Factory)</a></li>
<li><a href="#sec-2-1-2">2.1.2. 工厂方法模式</a></li>
<li><a href="#sec-2-1-3">2.1.3. 抽象工厂</a></li>
<li><a href="#sec-2-1-4">2.1.4. 创建者模式(Builder)</a></li>
<li><a href="#sec-2-1-5">2.1.5. 原型模式 (Prototype)</a></li>
<li><a href="#sec-2-1-6">2.1.6. 单例模式 (Singleton)</a></li>
<li><a href="#sec-2-1-7">2.1.7. 多例模式(Multition pattern)</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. 结构型模式</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. 外观模式(Facade)</a></li>
<li><a href="#sec-2-2-2">2.2.2. 适配器模式(Adapter)</a></li>
<li><a href="#sec-2-2-3">2.2.3. 装饰者模式(Decorator)</a></li>
<li><a href="#sec-2-2-4">2.2.4. 代理模式(Proxy)</a></li>
<li><a href="#sec-2-2-5">2.2.5. 桥模式(Bridge)</a></li>
<li><a href="#sec-2-2-6">2.2.6. 组合模式(Composite)</a></li>
<li><a href="#sec-2-2-7">2.2.7. 享元模式(Flyweight)</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3. 行为型模式</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. 模板方法</a></li>
<li><a href="#sec-2-3-2">2.3.2. 策略模式 (Strategy)</a></li>
<li><a href="#sec-2-3-3">2.3.3. 观察者模式 (Observer)</a></li>
<li><a href="#sec-2-3-4">2.3.4. 责任链模式(Chain of responsibility pattern):</a></li>
<li><a href="#sec-2-3-5">2.3.5. 备忘录模式(Memento pattern):</a></li>
<li><a href="#sec-2-3-6">2.3.6. 状态模式(State pattern):</a></li>
<li><a href="#sec-2-3-7">2.3.7. 访问者模式(visitor pattern):</a></li>
<li><a href="#sec-2-3-8">2.3.8. 命令模式(Command pattern):</a></li>
<li><a href="#sec-2-3-9">2.3.9. 解释器模式(Interpreter pattern):</a></li>
<li><a href="#sec-2-3-10">2.3.10. 中介者模式(Mediator pattern) :</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="main">


<p>
使用模式最好的方式: <b>把模式装进脑子里,然后在你的设计和已有应用中,寻找何处可以使用他们.以往是代码复用,现在是经验复用</b>.&#x2013; head first design pattern.
</p>


<!-- more -->


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 设计原则</h2>
<div class="outline-text-2" id="text-1">
<p>
面向对象设计原则是OOPS（Object-Oriented Programming System,面向对象的程序设计系统）编程的核心,Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> DRY</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Don't repeat yourself.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 封装变化</h3>
<div class="outline-text-3" id="text-1-2">
<p>
找出应用中可能需要变化之处,把它们独立出来,不要和那些不需要变化的代码混在一起.在软件领域中唯一不变的就是“Change”，因此封装你认为或猜测未来将发生变化的代码
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 针对接口编程,而不是针对实现编程</h3>
<div class="outline-text-3" id="text-1-3">
<p>
{% highlight java %}
Duck duck = new MallardDark(); // 使用Duck接口让java更有弹性
{% endhighlight %}
</p>
</div>
</div>



<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 合成复用原则</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Composite Reuse Principle.多用组合,少用继承.
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 里氏替换原则</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Liskov Substitution PRINCIPLE.继承与派生的规则.
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 单一职责原则</h3>
<div class="outline-text-3" id="text-1-6">
<p>
SINGLE RESPONSIBILITY PRINCIPLE.一个类负责一项职责.
</p>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> 接口隔离原则</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Interface Segregation Principle.建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少.
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> 开闭原则</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Open Close Principle.类应该对拓展开放,对修改关闭,实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。
</p>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> 依赖倒转原则</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Dependence Inversion Principle.要依赖抽象,不要依赖具体类. 
</p>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> 迪米特法则</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Demeter Principle,又叫最少知道原则.一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。只和你的密友谈话.(Least knowledge),减少对象间的交互,只留下几个密友.
</p>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> 好莱坞原则</h3>
<div class="outline-text-3" id="text-1-11">
<p>
别调用(打电话给)我们,我们会调用(打电话给)你.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 23种设计模式</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 创建型模式</h3>
<div class="outline-text-3" id="text-2-1">
<p>
前面讲过，社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：-《易学设计模式》
</p>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> 简单工厂(Simple Factory)</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Simple Factory模式又称为Static Factory模式.一个Simple Factory生产产品,而对客户隐藏产品产生细节,物件如何生成,生成前是否与其它物件建立依赖关系，客戶端皆不用理会，用以将物件生成方式之变化 与客戶端程式隔离。
</p>

<p>
<b>简单工厂其实并不能算作是一种设计模式，只是编程过程中对问题经常处理的一种习惯。</b>
</p>

<p>
{% highlight java %}
public class SimpleFactory{
    public static SimpleFactory getProduct(String type){
        if(type==""){
            return new Product();
        }
    }
}
{% endhighlight %}
</p>

<p>
Simple Factory使用静态方法來简单地隐藏物件建立细节。撇开静态方法不谈，隐藏物件建立的细节仍是Factory模式的重点，可将这个模式推至极致，而成为一种通用、专门用来生成物件、建立依赖关系、甚至具备管理物件生命周期职责的轻量级容器。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> 工厂方法模式</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
定义了一个创建对象的接口,但由子类决定实例化哪一个.工厂方法让类把实例化推迟到子类.
</p>


<div class="figure">
<p><img src="{{site.url}}/assets/images/pattern/factory.png" alt="factory.png" />
</p>
</div>

<p>
尽量达到这个原则.如果有个类可能改变,可以采用工厂.但是实例化字符串就不必,因为字符串不可能改变.
</p>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> 抽象工厂</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类.
</p>
</div>
</div>

<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4"><span class="section-number-4">2.1.4</span> 创建者模式(Builder)</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
使用生成器模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示.
</p>
</div>
</div>

<div id="outline-container-sec-2-1-5" class="outline-4">
<h4 id="sec-2-1-5"><span class="section-number-4">2.1.5</span> 原型模式 (Prototype)</h4>
<div class="outline-text-4" id="text-2-1-5">
<p>
当创建给定类的实例过程很昂贵或很复杂时, 就使用原形模式.
</p>
</div>
</div>

<div id="outline-container-sec-2-1-6" class="outline-4">
<h4 id="sec-2-1-6"><span class="section-number-4">2.1.6</span> 单例模式 (Singleton)</h4>
<div class="outline-text-4" id="text-2-1-6">
<p>
单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-7" class="outline-4">
<h4 id="sec-2-1-7"><span class="section-number-4">2.1.7</span> 多例模式(Multition pattern)</h4>
<div class="outline-text-4" id="text-2-1-7">
<p>
在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题.
</p>
</div>
</div>
</div>


<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 结构型模式</h3>
<div class="outline-text-3" id="text-2-2">
<p>
在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 外观模式(Facade)</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
提供了一个统一的接口,用来访问子系统中的一群接口.外观定义了一个高层接口,让子系统更容易使用.
</p>


<div class="figure">
<p><img src="{{site.url}}/assets/images/pattern/QQ截图20150507115515.png" alt="QQ截图20150507115515.png" />
</p>
</div>

<ul class="org-ul">
<li>外观模式和适配器模式比较
</li>
</ul>


<div class="figure">
<p><img src="{{site.url}}/assets/images/pattern/QQ截图20150507115247.png" alt="QQ截图20150507115247.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 适配器模式(Adapter)</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
将一个类的接口,转换成客户期望的另一个接口.适配器让原本接口不兼容的类可以合作无间.
</p>

<ul class="org-ul">
<li>适配器和装饰者比较
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 装饰者模式(Decorator)</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
动态的将责任附件到对象上,若要拓展功能,装饰者提供了比继承更有弹性的替代方案.
通常抓装饰者模式采用的是抽象类.
<img src="{{site.url}}/assets/images/pattern/decoreate-io.png" alt="decoreate-io.png" />
<img src="{{site.url}}/assets/images/pattern/decoreate.png" alt="decoreate.png" />
</p>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 代理模式(Proxy)</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
为另一个对象提供一个替身或占位符以控制对这个对象的访问.
</p>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> 桥模式(Bridge)</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变.
</p>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6"><span class="section-number-4">2.2.6</span> 组合模式(Composite)</h4>
<div class="outline-text-4" id="text-2-2-6">
<p>
允许你将对象组合成树形结构来表现"整体/部分"层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合.
</p>
</div>
</div>

<div id="outline-container-sec-2-2-7" class="outline-4">
<h4 id="sec-2-2-7"><span class="section-number-4">2.2.7</span> 享元模式(Flyweight)</h4>
<div class="outline-text-4" id="text-2-2-7">
<p>
如想让某个类的一个实例能用来提供许多"虚拟实例", 就使用蝇量模式.
</p>
</div>
</div>
</div>


<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 行为型模式</h3>
<div class="outline-text-3" id="text-2-3">
<p>
在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> 模板方法</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中.模板方法使得子类可以在不改变算法结构的情况下,重新定义算法中的某些步骤.
</p>


<div class="figure">
<p><img src="{{site.url}}/assets/images/pattern/QQ截图20150507151717.png" alt="QQ截图20150507151717.png" />
</p>
</div>

<ul class="org-ul">
<li>钩子
</li>
</ul>


<div class="figure">
<p><img src="{{site.url}}/assets/images/pattern/QQ截图20150507152838.png" alt="QQ截图20150507152838.png" />
</p>
</div>

<div class="org-src-container">

<pre class="src src-java">public abstract class WithHook{

   void moduleMethod(){
	  // some method ...

	  if(customerWantCondiments()){addCondiments();}
   }

   boolean customerWantCondiments(){return false;}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> 策略模式 (Strategy)</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。
</p>
</div>
</div>

<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3"><span class="section-number-4">2.3.3</span> 观察者模式 (Observer)</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
观察者模式定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新.
又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。
</p>


<div class="figure">
<p><img src="{{site.url}}/assets/images/pattern/QQ截图20150505153415.png" alt="QQ截图20150505153415.png" />
</p>
</div>


<div class="figure">
<p><img src="{{site.url}}/assets/images/pattern/QQ截图20150505112050.png" alt="QQ截图20150505112050.png" />
</p>
</div>

<p>
观察者模式（有时又被称为发布-订阅Subscribe&gt;模式、模型-视图View&gt;模式、源-收听者Listener&gt;模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。
</p>
</div>
</div>

<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4"><span class="section-number-4">2.3.4</span> 责任链模式(Chain of responsibility pattern):</h4>
<div class="outline-text-4" id="text-2-3-4">
<p>
通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-5" class="outline-4">
<h4 id="sec-2-3-5"><span class="section-number-4">2.3.5</span> 备忘录模式(Memento pattern):</h4>
<div class="outline-text-4" id="text-2-3-5">
<p>
当你需要让对象返回之前的状态时(例如, 你的用户请求"撤销"), 你使用备忘录模式.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-6" class="outline-4">
<h4 id="sec-2-3-6"><span class="section-number-4">2.3.6</span> 状态模式(State pattern):</h4>
<div class="outline-text-4" id="text-2-3-6">
<p>
允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-7" class="outline-4">
<h4 id="sec-2-3-7"><span class="section-number-4">2.3.7</span> 访问者模式(visitor pattern):</h4>
<div class="outline-text-4" id="text-2-3-7">
<p>
当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-8" class="outline-4">
<h4 id="sec-2-3-8"><span class="section-number-4">2.3.8</span> 命令模式(Command pattern):</h4>
<div class="outline-text-4" id="text-2-3-8">
<p>
将"请求"封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-9" class="outline-4">
<h4 id="sec-2-3-9"><span class="section-number-4">2.3.9</span> 解释器模式(Interpreter pattern):</h4>
<div class="outline-text-4" id="text-2-3-9">
<p>
使用解释器模式为语言创建解释器.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-10" class="outline-4">
<h4 id="sec-2-3-10"><span class="section-number-4">2.3.10</span> 中介者模式(Mediator pattern) :</h4>
<div class="outline-text-4" id="text-2-3-10">
<p>
使用中介者模式来集中相关对象之间复杂的沟通和控制方式.
</p>

</div>
</div>
</div>
</div>
</div>
